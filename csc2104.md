# CSC 2104 - Operating System Fundamentals

**Lecturer**: Dr Chia Wai Chong

**Textbook used**: Operating System Concepts, 9th Edition by Gagne, Galvin, Silberschatz. Wiley & Sons

![textbook cover](/assets/csc2104-textbook-cover.jpeg)

[Back to Home](index.md)

## Contents

- [CSC 2104 - Operating System Fundamentals](#csc-2104---operating-system-fundamentals)
    - [Contents](#contents)
    - [Tutorial Notes](#tutorial-notes)
        - [Tutorial 1](#tutorial-1)
        - [Tutorial 2](#tutorial-2)
        - [Tutorial 3](#tutorial-3)
            - [Question 1](#question-1)
            - [Question 2](#question-2)
            - [Question 3](#question-3)
        - [Tutorial 4](#tutorial-4)
            - [A. Threading](#a-threading)
            - [B. Deadlock](#b-deadlock)
            - [C. Memory Management](#c-memory-management)
        - [Tutorial 5](#tutorial-5)
    - [Lecture Notes](#lecture-notes)
        - [Week 1 - Introduction](#week-1---introduction)
        - [Week 2 - Operating System Structure](#week-2---operating-system-structure)
        - [Week 3 - Process Concept](#week-3---process-concept)
        - [Week 4 - Process Scheduling](#week-4---process-scheduling)
        - [Week 5 - Threading](#week-5---threading)
        - [Week 6 - Synchronization & Deadlock](#week-6---synchronization--deadlock)
        - [Week 7 - Memory Management](#week-7---memory-management)
        - [Week 8 - File Systems](#week-8---file-systems)

---

## Tutorial Notes

---

### Tutorial 1

1. Why is main memory not suitable for permanent storage or backup purposes? Furthermore, what is the main disadvantage to store information on a magnetic disk drive as opposed to main memory?

2. Identify **TWO** advantages and **TWO** disadvantages of open-source operating systems (eg. Linux).

3. Explain why an operating system can be viewed as a resource allocator.

4. What are the **TWO** fundamental approaches for users to interface with the operating system? Discuss, from your point-of-view, which approach is better.

5. Describe the CPU's two modes of operation (user mode and kernel mode).

6. What are the main factors that a programmer would take into consideration when designing an operating system for a smart TV?

7. There are **TWO** different ways that commands can be processed by a command-;ine interpreter. One way is to allow the command interpreter to contain the code needed to execute the command. The other way is to implement the commands through system programs. Compare and contrast the two approaches.

---

### Tutorial 2

1. What is the advantage and disadvantage of the microkernel approach when compared to the monolithic approach?
    - Advantage:
        - A simpler kernel design and functionality typically results in a more reliable operating system (less bugs)
        - Smaller file size, faster loading time
    - Disadvantage:
        - Overhead associated with inter-process communication (frequent use of the messaging functions for the user process and the system service to interact with each other)
        - Larger file size, slower loading time

2. What is a dynamically loadable module?
    - Modules can be selected and added to the kernel during runtime
    - For example, a device driver is loaded into the kernel only when the device is connected to the computer system.
    - Linux Kernel Module:
        - Extend functionalities without having to recompile the kernel
            - Develop driver to support new hardware
        - Can be loaded or unloaded from the kernel during runtime.
        - Higher level of execution privilege.

3. Describe FOUR advantages of using a virtual machine?
    - Runs multiple operating systems concurrently  on the same machine
    - Host system is protected from the guest server
    - Rapid porting and testing of programs in different environments.
    - Server consolidation where different services can now run on the same machine
    - Provides a good platform for OS research

4. What is the difference between a Type 1 hypervisor and a Type 2 hypervisor?

5. Compare and contrast the TWO inter-process communication models?
    - Message-Passing Model:
        - Useful for exchanging smaller amounts of data, because no conflicts need to be avoided (don't have to worry about race condition)
        - Easier to implement for communication between different systems (can also be implemented for communication within a computer)

    - Shared-Memory Model:
        - Maximum speed and convenience of communcation
        - Can be done at memory transfer speed when it takes place within a computer

6. What is the main factor that must be taken into consideration when processes communicate using the shared-memory model?
    - Synchronization
        - Ensure that two processes are not allowed to modify data stored in a memory location at the same time (to avoid data inconsistency)
        - A process should retrieve data stored in a memory location after the data is updated by another process


7. If a synchronous type of communication is required, what is the requirement that should be imposed on the sender and the receiver in the message-passing model?
    - Blocking send and blocking receive
    - The sender is blocked until the message is received by the receiving process or by the mailbox and the receiver is blocked until a message is available

8. What is the main difference between multi-programming and time-sharing in terms of execution?
    - Multiprogramming : The CPU will switch to execute another process __when the current process has to enter the waiting state__
    - Time-sharing : The CPU will switch to execute another process __when the time slice has expired (each process is only allocated within a specific time slice for execution)__

9. Is it possible to implement both multi-programming and time-sharing techniques into an operating system and having them running simultaneously? If YES, explain how it could be done. If NO, explain why it is not possible and justify your answer.
    - Yes, multi-programming can be applied to background processes whereas time-sharing for foreground processes

10. Describe the characteristics of short-term scheduler, medium-term scheduler, and long-term scheduler.
    - Short-Term Scheduler
        - Select which process to be executed by the CPU
        - Must select a new processs for the CPU frequently
    - Medium-Term Scheduler
        - Select which process to be brought into the ready queue
        - Execute less frequently than the short-term scheduler
    - Long-Term Scheduler
        - Determine which process to be swapped-out from / swapped into the memory
        - Swap out inactive process to create space for new processes

---

### Tutorial 3

#### Question 1

| Process | Arrival Time (ms) | Burst Time (ms) | Priority* |
| ------- | ----------------- | --------------- | --------- |
| P1      | 0                 | 15              | 5         |
| P2      | 3                 | 2               | 1         |
| P3      | 4                 | 6               | 3         |
| P4      | 8                 | 2               | 4         |
| P5      | 12                | 10              | 2         |

`*Note: Smaller number, higher priority`

1. Draw four Gantt charts that illustrate the execution of these processes using the FCFS, SJF, Preemptive Priority, and RR (quantum = 2 ms) scheduling algorithms.

    ![answers](/assets/csc2104-t3q1a.png)

2. Determine the **turnaround time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average turnaround time**.

3. Determine the **waiting time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average waiting time**.

    ![answers](/assets/csc2104-t3q1.png)

#### Question 2

| Process | Arrival Time (ms) | Burst Time (ms) | Priority* |
| ------- | ----------------- | --------------- | --------- |
| P1      | 0                 | 6               | 2         |
| P2      | 3                 | 5               | 1         |
| P3      | 4                 | 2               | 3         |
| P4      | 8                 | 4               | 5         |
| P5      | 12                | 9               | 4         |

`*Note: Smaller number, higher priority`

1. Draw four Gantt charts that illustrate the execution of these processes using the FCFS, SJF, Preemptive Priority, and RR (quantum = 2 ms) scheduling algorithms.

    ![answers](/assets/csc2104-t3q2a.png)

2. Determine the **turnaround time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average turnaround time**.

3. Determine the **waiting time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average waiting time**.

    ![answers](/assets/csc2104-t3q2.png)

#### Question 3

| Process | Arrival Time (ms) | Burst Time (ms) | Priority* |
| ------- | ----------------- | --------------- | --------- |
| P1      | 0                 | 2               | 4         |
| P2      | 1                 | 1               | 2         |
| P3      | 3                 | 7               | 5         |
| P4      | 8                 | 2               | 1         |
| P5      | 10                | 3               | 3         |

`*Note: Smaller number, higher priority`

1. Draw four Gantt charts that illustrate the execution of these processes using the FCFS, SJF, Preemptive Priority, and RR (quantum = 2 ms) scheduling algorithms.

    ![answers](/assets/csc2104-t3q3a.png)

2. Determine the **turnaround time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average turnaround time**.

3. Determine the **waiting time** of each process for each of the scheduling algorithms in part (a). Also, calculate the **average waiting time**.

    ![answers](/assets/csc2104-t3q3.png)

---

### Tutorial 4

#### A. Threading

1. Describe the relationship between threads and processes.

    A process, which has its own memory space, is like a container for the threads. The threads share that memory space and they are the units of execution within the process. Each thread has its own set of registers, stack, and program counter.

2. If an application or function needs to be implemented as a set of related units of execution, why is it more efficient to do so as a collection of threads rather than a collection of separate processes?

    - Takes less time to create new threads in an existing process than to create an brand new process.
    - Takes less time to switch between two threads within the same process (less information to save)
    - Threads sharing the same user address space allow communication to take place without intervention from the kernel.

#### B. Deadlock

1. Describe the **FOUR** conditions that must hold simultaneously for a deadlock to occur.

    - **Mutual Exclusion** - a resource can be accessed by only one process at a time.
    - **Hold and Wait** - a process is holding at least one resource and is waiting to acquire additional resources that are currently being held by other processes.
    - **No Preemption** - resources cannot be preempted. The resources can only be released voluntarily by the process that is currently holding it.
    - **Circular wait** - two or more processes form a circular waiting chain, where each process waits for a resource at the next process in the chain holds.

2. What is the difference between deadlock prevention and deadlock avoidance.

    - Deadlock prevention is to ensure that at least one of the four conditions required to form a deadlock can never happen. It does not dynamically examine the resource allocation and make use of additional information to avoid allocation that might eventually lead to deadlock.

3. Given a set of active processes (P), a set of resources in a computer system (R), and a set of edges (E):

    `P = {P1, P2, P3}`

    `R = {R1, R2, R3, 2 x R4}`

    `E = {P1->R1,R4->P1,R3->P3,P3->R2,R2->P2,P2->R3,P3->R4}`

    If a resource can only be accessed by one process at a time, and a resource cannot be preempted, explain whether the computer system is in the deadlock state. You may assume that a process is in the running state if it is not requesting nor waiting for other resources.

#### C. Memory Management

1. Given **FIVE** memory partitions of 200 KB, 400 KB, 100 KB, 300 KB, and 700 KB (in order). How would each of the first-fit, next-fit, best-fit, and worst-fit algorithms place processes of 256 KB, 117 KB, 412 KB, and 226 KB (in order)?

    | Partition \ Fit | First-Fit     | Next-Fit      | Best-Fit      | Worst-Fit     |
    | --------------- | ------------- | ------------- | ------------- | ------------- |
    | 256 KB          | 400KB (114KB) | 400KB (144KB) | 300KB (44KB)  | 700KB (444KB) |
    | 117 KB          | 200KB (83KB)  | 144KB (27KB)  | 200KB (83KB)  | 444KB (327KB) |
    | 412 KB          | 700KB (288KB) | 700KB (288KB) | 700KB (288KB) | Wait          |
    | 226 KB          | 300KB (74KB)  | 288KB (62KB)  | 288KB (62KB)  | 400KB (174KB) |

2. Given **FIVE** memory partitions of 600 KB, 400 KB, 300 KB, 200 KB, and 100 KB (in order). How would each of the first-fit, next-fit, best-fit, and worst-fit algorithms place processes of 100 KB, 438 KB, 202 KB, and 337 KB (in order)?

    | Partition \ Fit | First-Fit     | Next-Fit      | Best-Fit      | Worst-Fit     |
    | --------------- | ------------- | ------------- | ------------- | ------------- |
    | 100 KB          | 600KB (500KB) | 600KB (500KB) | 100KB (0KB)   | 600KB (500KB) |
    | 438 KB          | 500KB (62KB)  | 500KB (62KB)  | 600KB (162KB) | 500KB (62KB)  |
    | 202 KB          | 400KB (198KB) | 400KB (198KB) | 300KB (98KB)  | 400KB (198KB) |
    | 337 KB          | Wait          | Wait          | 400KB (63KB)  | Wait          |

---

### Tutorial 5

1. Suggest a way to reduce external fragmentation and briefly explain the drawback of your suggestion.

2. What is paging and why is is better than dynamic partitioning?

    Paging is . No external fragmentation when paging is used.

3. Describe page fault and explain how it will be handled.

4. Describe the relationship between demand paging and page fault.

5. Instead of using demand paging, do you think it is a good idea to preload/prefetch the pages of a process into the main memory before they are accessed? Justify your answer.

6. What are the advantages and disadvantages of using a smaller page size when compared to a larger page size?

7. Consider a process 4GB virtual and physical address space. If the page size in such a system is 4KB, calculate the amount of physical memory space that is required to store the page table of the process. You can assume that 4B of memory is required to store an entry in the page table.

8. What is a translation lookaside buffer (TLB) ?

9. A system using dynamic partitioning has five empty memory partitions of 300KB, 200KB, 500KB, 250KB, and 700KB (in order). Determine how would each of the first-fit, next-fit, best-fit, and worst-fit algorithms place processes of 128KB, 100KB, 398KB, and 493KB (in order)?

## Lecture Notes

### Week 1 - Introduction

### Week 2 - Operating System Structure

### Week 3 - Process Concept

### Week 4 - Process Scheduling

### Week 5 - Threading

### Week 6 - Synchronization & Deadlock

### Week 7 - Memory Management

### Week 8 - File Systems

